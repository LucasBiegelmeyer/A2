|| Exercícios de Funções || 

F00000100 - Escreva uma função no Delphi responsável por implementar a raiz cúbica. Utilize como nome da função algo como raizc, que recebe um número inteiro (INTEGER) e retorne a raiz cúbica do número (REAL). A raiz cúbica pode ser obtida elevando o número a potência de 1/3. Utilize a função power do Delphi para resolver a potência da base (N) pelo expoente (1/3). Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o número e retorne na saída padrão (ShowMessage) ou TLabel a raiz cúbica calculada.

F00000200 - Escreva uma função no Delphi responsável por implementar a raiz quadrada. Utilize como nome da função algo como raizq, que recebe um número inteiro (INTEGER) e retorne a raiz quadrada do número (REAL). A raiz quadrada pode ser obtida elevando o número a potência de 1/2. Utilize a função power do Delphi para resolver a potência da base (N) pelo expoente (1/2). Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o número e retorne na saída padrão (ShowMessage) ou TLabel a raiz quadrada calculada.

F00000300 - Escreva uma função no Delphi responsável por verificar se um número é primo ou não. Utilize como nome da função algo como primov, que recebe um número inteiro (INTEGER) e retorna (1) se o número for primo (0) se não for e (-1) se o número informado não puder ser calculado. Verifique a entrada antes de realizar o cálculo, pois números menores que 1 não são primos. O número primo é um número inteiro divisível apenas por 1 e por ele mesmo. Por exemplo, 3 é primo pois possui divisão perfeita (inteira) com resto zero entre 1 e 3. Já 8 não é, pois possui divisores como 2 e 4, além de 1 e 8. Faça um laço de 2 até N-1, e guarde a cada iteração se encontrou um divisor. No final, verifique se o contador permanece em zero. Este contador lhe ajudará a resolver o problema (lógica). Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o número primo e retorne na saída padrão (ShowMessage) ou TLabel as mensagens (É PRIMO) (NÃO É PRIMO) (ENTRADA NÃO SUPORTADA).

F00000400 - Escreva uma função no Delphi responsável por receber 3 lados (REAL) de um triângulo e por retornar o tipo de triângulo informado. Os tipos de retorno podem ser: (1) Triângulo isóceles; (2) Triângulo escaleno; (3) Triângulo equilátero. Triângulos escalenos possuem 3 lados com tamanhos diferentes. Triângulos equiláteros possuem 3 lados com o mesmo tamanho. Triângulos isóceles possuem 2 lados com medidas iguais e um com medida diferente. O cálculo só deve ser feito com números positivos e maiores que zero. Para entradas inválidas, a função deve retornar (-1). Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o número de cada um dos 3 lados e retorne na saída padrão (ShowMessage) ou TLabel as mensagens (TRIÂNGULO EQUILÁTERO) (TRIÂNGULO ISÓCELES) (TRIÂNGULO ESCALENO) (ENTRADAS NÃO SUPORTADAS).

F00000500 - Escreva uma função no Delphi responsável por receber 2 números (INTEGER) e por verificar se os mesmos são amigos ou não. Números são amigos se a soma dos divisores de N1 (excluindo o próprio N1) é igual a N2 e se a soma dos divisores de N2 (excluindo o próprio N2) é igual a N1. Sua função deve retornar (1) se os 2 números informados para a função forem amigos (possuírem a propriedade anterior). Caso contrário deve retornar (0). Se uma das entradas forem negativas a função deve retornar (-1). Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit os dois números e retorne na saída padrão (ShowMessage) ou TLabel as mensagens (NÚMEROS AMIGOS) (NÚMEROS NÃO AMIGOS) (ENTRADAS NÃO SUPORTADAS).

F00000600 -  Escreva uma função no Delphi responsável por receber 3 valores sendo eles o DIA o MÊS e o ANO. A função deve verificar se a DATA recebida é válida retornando (1) se a data é válida ou (0) se não for válida. Considere que ano bissexto é aquele divisível por 4 e que abril, junho, setembro e novembro tem 30 dias, fevereiro tem 28 (29 em ano bissexto) e todos os outros meses tem 31 dias. Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o DIA o MES e o ANO e mostre na saída padrão (ShowMessage) ou TLabel o resultado (DATA VÁLIDA) ou (DATA NÃO VÁLIDA).

F00000700 - Escreva uma função no Delphi responsável por receber um valor N, e por retornar no final o fatorial do número N. Sua função deve verificar a entrada, realizando o cálculo apenas se o N for um valor maior do que zero. Caso a entrada não seja válida, a função deve retornar (-1). Caso o número seja válido a função, deverá retornar o fatorial do número. O fatorial é o somatório das multiplicações sucessivas de N por (N-1), até 1. (Ex: O fatorial de 5 é 5 * 4 * 3 * 2 * 1). Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o número a ser calculado o fatorial e mostre na saída padrão (ShowMessage) ou TLabel o resultado (FATORIAL) ou (ENTRADA NÃO SUPORTADA).

F00000800 - Escreva uma função no Delphi responsável por receber um valor N, e por retornar no final o maior número primo de N. Sua função deve verificar a entrada, realizando o cálculo apenas se o N for um valor maior do que zero. Caso a entrada não seja válida, a função deve retornar (-1). Caso o número seja válido a função, deverá retornar o maior número primo. O número primo é um número inteiro divisível apenas por 1 e por ele mesmo. Por exemplo, 3 é primo pois possui divisão perfeita (inteira) com resto zero entre 1 e 3. Já 8 não é, pois possui divisores como 2 e 4, além de 1 e 8. Faça um laço de 2 até N-1, e guarde a cada iteração se encontrou um divisor. No final, verifique se o contador permanece em zero. Este contador lhe ajudará a resolver o problema (lógica). Se você já realizou o problema F00000300, poderá fazer uso da função que o programa implementa. A função reduzirá o trabalho para resolver este programa. Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o número N e retorne na saída padrão (ShowMessage) ou TLabel as mensagens (MAIOR NÚMERO PRIMO É N) ou (ENTRADA NÃO SUPORTADA).

F00000900 - Escreva uma função no Delphi responsável por receber um valor N, e por retornar no final o menor número primo de N. Sua função deve verificar a entrada, realizando o cálculo apenas se o N for um valor maior do que zero. Caso a entrada não seja válida, a função deve retornar (-1). Caso o número seja válido a função, deverá retornar o menor número primo. O número primo é um número inteiro divisível apenas por 1 e por ele mesmo. Por exemplo, 3 é primo pois possui divisão perfeita (inteira) com resto zero entre 1 e 3. Já 8 não é, pois possui divisores como 2 e 4, além de 1 e 8. Faça um laço de 2 até N-1, e guarde a cada iteração se encontrou um divisor. No final, verifique se o contador permanece em zero. Este contador lhe ajudará a resolver o problema (lógica). Se você já realizou o problema F00000300, poderá fazer uso da função que o programa implementa. A função reduzirá o trabalho para resolver este programa. Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o número N e retorne na saída padrão (ShowMessage) ou TLabel as mensagens (MENOR NÚMERO PRIMO É N) ou (ENTRADA NÃO SUPORTADA).

F000001000 - Escreva uma função no Delphi responsável por receber um valor N, e por retornar no final o maior e o menor número primo de N. Sua função deve verificar a entrada, realizando o cálculo apenas se o N for um valor maior do que zero. Caso a entrada não seja válida, a função deve retornar (-1) em ambos os valores de retorno. Caso o número seja válido a função, deverá retornar o maior e o menor número primo. Neste problema sua função deverá possuir dois parâmetros, de maneira a permitir que dois valores (maior e menor) sejam retornados pela função. Existem outras formas de fazer com apenas um parâmetro, sendo que você é livre para utilizar a solução que achar mais simples de resolver o problema. O número primo é um número inteiro divisível apenas por 1 e por ele mesmo. Por exemplo, 3 é primo pois possui divisão perfeita (inteira) com resto zero entre 1 e 3. Já 8 não é, pois possui divisores como 2 e 4, além de 1 e 8. Faça um laço de 2 até N-1, e guarde a cada iteração se encontrou um divisor. No final, verifique se o contador permanece em zero. Este contador lhe ajudará a resolver o problema (lógica). Se você já realizou o problema F00000800 e F00000900, poderá fazer uso das funções anteriores para resolver este programa . As funções reduzirão o trabalho para resolver este programa. Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o número N e retorne na saída padrão (ShowMessage) ou TLabel as mensagens (MAIOR NÚMERO PRIMO É N E MENOR NÚMERO PRIMO É N) ou (ENTRADA NÃO SUPORTADA).

F000001100 - Escreva uma função no Delphi responsável por receber um valor N referente a um número de elementos que devem ser sorteados aleatoriamente utilizando rand e randomize em um intervalo de 0 até N. A função deve calcular quantos números primos foram gerados e retornar este valor. É responsabilidade da função retornar (-1) se o valor N informado for negativo. Se você já realizou o problema F00000300, poderá fazer uso da função que o programa implementa. A função reduzirá o trabalho para resolver este programa. Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o N e retorne na saída padrão (ShowMessage) ou TLabel as mensagens (A QUANTIDADE DE PRIMOS ENTRE 1 E N É X) ou (ENTRADA NÃO SUPORTADA).

F000001200 - Escreva uma função no Delphi responsável por receber um valor DEP referente a um depósito e um valor JUR referente ao juro pago por uma caderneta de poupança. A função deve retornar a quantidade de tempo (em dias) que a poupança consiga fazer o valor depositado (DEP) valer 3 vezes o valor iniciam. A caderneta de poupança assume que a cada 10 dias o JUR deve ser aplicado ao valor depositado. Por exemplo, se 100 reais aplicados a 10% de juros a cada 10 dias, rendem 133,1 reais em 30 dias. É responsabilidade da função retornar (-1) se o valor depositado for menor do que 1, e se o rendimento for menor do que 1. Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o DEP e o JUR e retorne na saída padrão (ShowMessage) ou TLabel as mensagens (A QUANTIDADE DE DIAS NECESSÁRIOS É ) ou (ENTRADA NÃO SUPORTADA).

F000001300 - Escreva uma função no Delphi responsável por receber um valor MIN e um valor MAX referente a um intervalo de valores. A função deve verificar se MIN é menor que MAX (Ex: 5 e 50), devendo retornar o somatório dos números ímpares do intervalo de valores. Caso a condição acima não seja atendida, a função deve retornar (-1). O somatório pode ser feito através do uso de uma variável acumuladora, que deve ser inicializada. Todo ímpar é um número que dividido por 2 possui resto diferente de zero. Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o MIN e o MAX e retorne na saída padrão (ShowMessage) ou TLabel as mensagens (O SOMATÓRIO DOS NÚMEROS ÍMPARES DE MIN ATÉ MAX É X) ou (ENTRADA NÃO SUPORTADA).

F000001400 - Escreva uma função no Delphi responsável por receber dois valores (INTEGER) e por calcular o MDC (Máximo Divisor Comum) dos números. Sua função deve verificar a entrada, realizando o cálculo apenas se ambos os números forem maiores do que zero. Caso a entrada não seja válida, a função deve retornar (-1). Caso contrário, deverá calcular e retornar o MDC. Considere que o MDC é o MAIOR número múltiplo (divisível) por  N1 e por N2. Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o N1 e o N2 e retorne na saída padrão (ShowMessage) ou TLabel as mensagens (O MDC de N1 e N2 É X) ou (ENTRADA NÃO SUPORTADA).

F000001500 - Escreva uma função no Delphi responsável por receber dois valores (INTEGER) e por calcular o MMC (Mínimo Múltiplo Comum) dos números. Sua função deve verificar a entrada, realizando o cálculo apenas se ambos os números forem maiores do que zero. Caso a entrada não seja válida, a função deve retornar (-1). Caso contrário, deverá calcular e retornar o MMC. Considere que o MMC é o MENOR número múltiplo (divisível) por  N1 e por N2. Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o N1 e o N2 e retorne na saída padrão (ShowMessage) ou TLabel as mensagens (O MMC de N1 e N2 É X) ou (ENTRADA NÃO SUPORTADA).

F000001600 - Escreva uma função no Delphi responsável por receber um valor SAL referente ao salário de uma pessoa e um segundo valor IMP que representa o percentual de imposto. Ambos os números devem ser utilizados para calcular o salário líquido (a receber) de um funcionário. É responsabilidade da função retornar (-1) se o salário informado for menor ou igual a zero, e se o imposto for menor do que 0 e maior do que 100. O cálculo do salário é feito multiplicando SAL por IMP/100 (fração). O imposto deve ser aplicado ao salário bruto (SAL), descontando o respectivo percentual de valor do mesmo. (Ex: O salário líquido do valor bruto 300 ao aplicar 15% de imposto é 255). Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o SAL e o IMP e retorne na saída padrão (ShowMessage) ou TLabel as mensagens (O SALÁRIO LÍQUIDO A RECEBER É X) ou (ENTRADA NÃO SUPORTADA).

F000001700 - Escreva uma função no Delphi responsável por receber um valor B referente a uma base e um valor E referente a um expoente e por retornar a potenciação dos números. Diferente dos programas já desenvolvidos, esta função NÃO DEVE fazer uso da função power do DELPHI. O programador deverá realizar a potência através de um processo iterativo de multiplicações sucessivas. A função deve receber a base e o expoente, podendo ser ambos números negativos. O exponente deve ser convertido para sua versão positiva, pois deve ser utilizado como valor limite do laço que irá calcular as multiplicações iterativas. Por fim, a função deve calcular a potência dos números passados por parâmetro. Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit a base (B) e o expoente (E) e retorne na saída padrão (ShowMessage) ou TLabel as mensagens (A BASE (B) ELEVADA AO EXPOENTE (E) É X) ou (ENTRADA NÃO SUPORTADA).

F000001900 - Escreva uma função no Delphi responsável por receber um valor N, e por retornar no final o enésimo número da série de fibonacci. Sua função deve verificar a entrada, realizando o cálculo apenas se o N for um valor maior do que zero. Caso a entrada não seja válida, a função deve retornar (-1) em ambos os valores de retorno. A série de fibonacci (0 1 1 2 3 5 8 13 21 34 55 ..) é calculada somando os dois últimos números da série, gerando o enésimo (próximo número) da série. Por exemplo, se o usuário digitar 1, a função deve retornar (0), sendo este o valor do primeiro elemento da série. Se o usuário informar 5 a função deve retornar 3, sendo este o valor do quinto elemento da série. Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o número N e retorne na saída padrão (ShowMessage) ou TLabel as mensagens (A POSIÇÃO N DA SÉRIE DE FIBONACCI É X) ou (ENTRADA NÃO SUPORTADA).

F000001900 - Escreva uma função no Delphi responsável por receber um valor N, e por retornar no final se o número é palíndromo ou não. Números palíndromos são iguais quando lidos no sentido contrário (como 222 ou 121). Sua função deve verificar a entrada, realizando o cálculo apenas se o N for um valor maior do que zero. Caso a entrada não seja válida, a função deve retornar (-1) em ambos os valores de retorno. Caso o número seja palíndromo a mesma deve retornar (1) e se não for, deve retornar (0). Existem várias soluções para calcular o número, como colocando o mesmo em um vetor de caracteres (string) e realizando a leitura do vetor de trás pra frente. Outra solução é dividir o número por 10 e pegar cada unidade que deve ser somada ao novo número (e multiplicado por 10^(TAM-1)), sendo TAM o número de dígitos do número. Por exemplo, o número 1234 poderia em um laço ser dividido por 10 4 vezes onde a cada iteração os números 4 * 1000 + 3 * 100 + 2 * 10 + 1 seriam decompostos, podendo se obter 4321 (o contrário de 1234). Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o número N e retorne na saída padrão (ShowMessage) ou TLabel as mensagens (palíndromo) ou (NÃO palíndromo) ou (ENTRADA NÃO SUPORTADA).

F000002000 - Escreva uma função no Delphi responsável por receber um valor N, e por retornar no final se o número é palíndromo ou não. Números palíndromos são iguais quando lidos no sentido contrário (como 222 ou 121). Sua função deve verificar a entrada, realizando o cálculo apenas se o N for um valor maior do que zero. Caso a entrada não seja válida, a função deve retornar (-1) em ambos os valores de retorno. Caso o número seja palíndromo a mesma deve retornar (1) e se não for, deve retornar (0). Existem várias soluções para calcular o número, como colocando o mesmo em um vetor de caracteres (string) e realizando a leitura do vetor de trás pra frente. Outra solução é dividir o número por 10 e pegar cada unidade que deve ser somada ao novo número (e multiplicado por 10^(TAM-1)), sendo TAM o número de dígitos do número. Por exemplo, o número 1234 poderia em um laço ser dividido por 10 4 vezes onde a cada iteração os números 4 * 1000 + 3 * 100 + 2 * 10 + 1 seriam decompostos, podendo se obter 4321 (o contrário de 1234). Faça ainda um programa VCL (mínimo) que receba da entrada padrão (InputBox) ou de um TEdit o número N e retorne na saída padrão (ShowMessage) ou TLabel as mensagens (palíndromo) ou (NÃO palíndromo) ou (ENTRADA NÃO SUPORTADA).
